// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc {{.SqlcVersion}}

package {{.Package}}

{{range imports .SourceName}}
{{range .}}import {{.}}
{{end}}
{{end}}

{{range .Queries}}
const val {{.ConstantName}} = {{$.Q}}-- name: {{.MethodName}} {{.Cmd}}
{{.SQL}}
{{$.Q}}

{{if .Ret.EmitStruct}}
data class {{.Ret.Type}} ( {{- range $i, $e := .Ret.Struct.Fields}}
  {{- if $i }},{{end}}
  val {{.Name}}: {{.Type}}
  {{- end}}
)
{{end}}
{{end}}

class QueriesImpl(private val conn: Connection) : Queries {
{{range .Queries}}
{{if eq .Cmd ":one"}}
{{range .Comments}}//{{.}}
{{end}}
  @Throws(SQLException::class)
  override fun {{.MethodName}}({{.Arg.Args}}): {{.Ret.Type}}? {
    return conn.prepareStatement({{.ConstantName}}).use { stmt ->
      {{.Arg.Bindings}}

      val results = stmt.executeQuery()
      if (!results.next()) {
        return null
      }
      val ret = {{.Ret.ResultSet}}
      if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
      }
      ret
    }
  }
{{end}}

{{if eq .Cmd ":many"}}
{{range .Comments}}//{{.}}
{{end}}
  @Throws(SQLException::class)
  override fun {{.MethodName}}({{.Arg.Args}}): List<{{.Ret.Type}}> {
    return conn.prepareStatement({{.ConstantName}}).use { stmt ->
      {{.Arg.Bindings}}

      val results = stmt.executeQuery()
      val ret = mutableListOf<{{.Ret.Type}}>()
      while (results.next()) {
          ret.add({{.Ret.ResultSet}})
      }
      ret
    }
  }
{{end}}

{{if eq .Cmd ":exec"}}
{{range .Comments}}//{{.}}
{{end}}
  @Throws(SQLException::class)
  {{ if $.EmitInterface }}override {{ end -}}
  override fun {{.MethodName}}({{.Arg.Args}}) {
    conn.prepareStatement({{.ConstantName}}).use { stmt ->
      {{ .Arg.Bindings }}

      stmt.execute()
    }
  }
{{end}}

{{if eq .Cmd ":execrows"}}
{{range .Comments}}//{{.}}
{{end}}
  @Throws(SQLException::class)
  {{ if $.EmitInterface }}override {{ end -}}
  override fun {{.MethodName}}({{.Arg.Args}}): Int {
    return conn.prepareStatement({{.ConstantName}}).use { stmt ->
      {{ .Arg.Bindings }}

      stmt.execute()
      stmt.updateCount
    }
  }
{{end}}

{{if eq .Cmd ":execresult"}}
{{range .Comments}}//{{.}}
{{end}}
  @Throws(SQLException::class)
  {{ if $.EmitInterface }}override {{ end -}}
  override fun {{.MethodName}}({{.Arg.Args}}): Long {
    return conn.prepareStatement({{.ConstantName}}, Statement.RETURN_GENERATED_KEYS).use { stmt ->
      {{ .Arg.Bindings }}

      stmt.execute()

      val results = stmt.generatedKeys
      if (!results.next()) {
          throw SQLException("no generated key returned")
      }
	  results.getLong(1)
    }
  }
{{end}}
{{end}}
}

