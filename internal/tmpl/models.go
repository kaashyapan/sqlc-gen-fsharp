package tmpl

import (
	"fmt"
	"io"

	"github.com/kaashyapan/sqlc-gen-fsharp/internal/core"
	"github.com/kaashyapan/sqlc-gen-fsharp/internal/templates"
	"github.com/tabbed/sqlc-go/sdk"
)

func Models(w io.Writer, dot core.TmplCtx) (err error) {
	defer func() {
		if recovered := recover(); recovered != nil {
			var ok bool
			if err, ok = recovered.(error); !ok {
				panic(recovered)
			}
		}
	}()

	templates.WriteModels(w, dot)
	return nil

	//return fsModelsTmpl(w, dot)
}

func fsModelsTmpl(w io.Writer, dot core.TmplCtx) error {

	_, _ = io.WriteString(w, "// Code generated by sqlc. DO NOT EDIT.\n// versions:\n//   sqlc ")
	_, _ = io.WriteString(w, dot.SqlcVersion)
	_, _ = io.WriteString(w, "\n\nmodule ")
	_, _ = io.WriteString(w, dot.Package)
	_, _ = io.WriteString(w, ".Models ")
	_, _ = io.WriteString(w, "\n\n")
	for _, dot := range core.Imports(dot.SourceName, dot.Package) {
		_ = dot
		_, _ = io.WriteString(w, "\n")
		_ = dot
		_, _ = io.WriteString(w, "open ")
		_, _ = io.WriteString(w, dot)

	}

	_, _ = io.WriteString(w, "\n")
	if eval := dot.Enums; len(eval) != 0 {
		for _, dot := range eval {
			_ = dot
			_, _ = io.WriteString(w, "\n")
			if eval := dot.Comment; len(eval) != 0 {
				_, _ = io.WriteString(w, core.DoubleSlashComment(dot.Comment))
			}
			_, _ = io.WriteString(w, "\nenum class ")
			_, _ = io.WriteString(w, dot.Name)
			_, _ = io.WriteString(w, "(val value: String) {")
			if eval := dot.Constants; len(eval) != 0 {
				for _Vari, _Vare := range eval {
					_ = _Vari
					dot := _Vare
					_ = dot
					if eval := _Vari; eval != 0 {
						_, _ = io.WriteString(w, ",")
					}
					_, _ = io.WriteString(w, "\n  ")
					_, _ = io.WriteString(w, dot.Name)
					_, _ = io.WriteString(w, "(\"")
					_, _ = io.WriteString(w, dot.Value)
					_, _ = io.WriteString(w, "\")")
				}
			}
			_, _ = io.WriteString(w, ";\n\n  companion object {\n    private val map = ")
			_, _ = io.WriteString(w, dot.Name)
			_, _ = io.WriteString(w, ".values().associateBy(")
			_, _ = io.WriteString(w, dot.Name)
			_, _ = io.WriteString(w, "::value)\n    fun lookup(value: String) = map[value]\n  }\n}\n")
		}
	}
	_, _ = io.WriteString(w, "\n\n")

	if eval := dot.DataClasses; len(eval) != 0 {
		for _, dot := range eval {
			_ = dot
			_, _ = io.WriteString(w, "\n")
			if eval := dot.Comment; len(eval) != 0 {
				_, _ = io.WriteString(w, core.DoubleSlashComment(dot.Comment))
			}
			_, _ = io.WriteString(w, "\ntype ")
			_, _ = io.WriteString(w, dot.Name)
			_, _ = io.WriteString(w, " = {")
			if eval := dot.Fields; len(eval) != 0 {
				for _Vari, _Vare := range eval {
					_ = _Vari
					dot := _Vare
					_ = dot

					if eval := dot.Comment; len(eval) != 0 {
						_, _ = io.WriteString(w, "\n  ")
						_, _ = io.WriteString(w, core.DoubleSlashComment(dot.Comment))
					}

					_, _ = io.WriteString(w, "\n  ")
					_, _ = io.WriteString(w, sdk.Title(dot.Name))
					_, _ = io.WriteString(w, ": ")
					_, _ = fmt.Fprint(w, dot.Type)
				}
			}
			_, _ = io.WriteString(w, "\n}\n")
		}
	}

	if eval := dot.Queries; len(eval) != 0 {
		for _, dot := range eval {
			_ = dot

			if dot.Ret.EmitStruct() {
				_, _ = io.WriteString(w, "type ")
				_, _ = io.WriteString(w, dot.Ret.Type())
				_, _ = io.WriteString(w, " = {")
				if eval := dot.Ret.Struct.Fields; len(eval) != 0 {
					for i, dot := range eval {
						_ = dot
						if i > 0 {
							_, _ = io.WriteString(w, ",")
						}
						_, _ = io.WriteString(w, "\n   ")
						_, _ = io.WriteString(w, dot.Name)
						_, _ = io.WriteString(w, ": ")
						_, _ = io.WriteString(w, dot.Type.String())
					}
				}
				_, _ = io.WriteString(w, " = }")

				_, _ = io.WriteString(w, "\n)\n\n")
			}
		}
	}

	_, _ = io.WriteString(w, "\n\n")
	return nil
}
